<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.2/math.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/1.4.4/jsxgraphcore.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/1.4.4/jsxgraph.css" />
    <title>Basic Math Review for FEM</title>
    <link rel="stylesheet" href="style.css" />
    <style>
      body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        color: #333;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f0f8ff;
      }
      h1,
      h2,
      h3 {
        color: #2c3e50;
      }
      .matrix-container {
        width: 100%;
        background-color: #fff;
        border: 1px solid #ddd;
        margin: 20px 0;
        padding: 10px;
        overflow-x: auto;
      }
      .interactive-demo {
        background-color: #e0f7fa;
        padding: 20px;
        border-radius: 10px;
        margin-top: 30px;
      }
      button {
        background-color: #3498db;
        color: white;
        border: none;
        padding: 10px 20px;
        cursor: pointer;
        font-size: 16px;
        border-radius: 5px;
        margin: 5px;
      }
      button:hover {
        background-color: #2980b9;
      }
      input[type="number"] {
        width: 50px;
        padding: 5px;
        font-size: 16px;
      }
      .math-formula {
        font-family: "Times New Roman", Times, serif;
        font-style: italic;
        background-color: #f9f9f9;
        padding: 5px;
        border-radius: 5px;
      }
      .calculation-steps {
        background-color: #fff;
        border: 1px solid #ddd;
        padding: 10px;
        margin-top: 10px;
        border-radius: 5px;
      }
      .step {
        margin-bottom: 10px;
      }
      .important-note {
        background-color: #ffe0b2;
        border-left: 5px solid #ff9800;
        padding: 10px;
        margin: 20px 0;
        font-weight: bold;
        font-weight: bold;
      }
      .zero-matrix-note {
        background-color: #e8f5e9;
        border-left: 5px solid #4caf50;
        padding: 10px;
        margin: 10px 0;
      }
      .properties-section {
        background-color: #e3f2fd;
        border: 1px solid #bbdefb;
        padding: 15px;
        margin: 20px 0;
        border-radius: 5px;
      }
      .property {
        margin-bottom: 15px;
      }
      .property-name {
        font-weight: bold;
        color: #1565c0;
      }
      table {
        border-collapse: collapse;
        margin: 10px 0;
      }
      td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: center;
      }
    </style>
    <script type="importmap">
      {
        "imports": {}
      }
    </script>
    <script>
      // Initialize JSXGraph boards
      let interpolationBoard
      let shapeFunctionsBoard
      let interpolationShapeBoard

      // Graph elements
      let point1, point2, interpolatedPoint, lineSegment, infiniteLine
      let shapeLine1, shapeLine2, shapePoint1, shapePoint2
      let shapeInterpolationComponents, shapeInterpolationSum

      function calculateBounds(x1, y1, x2, y2, x) {
        // Calculate bounds for interpolation canvas with 15% margin
        const minX = Math.min(x1, x2, x)
        const maxX = Math.max(x1, x2, x)
        const minY = Math.min(y1, y2)
        const maxY = Math.max(y1, y2)

        const rangeX = Math.max(maxX - minX, 50) // Minimum range to ensure axes are visible
        const rangeY = Math.max(maxY - minY, 50)

        const marginX = rangeX * 0.15 // Margin to ensure axes visibility
        const marginY = rangeY * 0.15

        // Ensure bounds include zero for axes visibility
        const boundMinX = Math.min(minX - marginX, -marginX)
        const boundMaxX = Math.max(maxX + 1.5 * marginX, marginX)
        const boundMinY = Math.min(minY - marginY, -marginY)
        const boundMaxY = Math.max(maxY + marginY, marginY)

        return {
          interpolation: [boundMinX, boundMaxY, boundMaxX, boundMinY],
          shapeFunction: [boundMinX, 1.15, boundMaxX, -0.15]
        }
      }

      function updateGraphs() {
        const x1 = parseFloat(document.getElementById("x1").value)
        const y1 = parseFloat(document.getElementById("y1").value)
        const x2 = parseFloat(document.getElementById("x2").value)
        const y2 = parseFloat(document.getElementById("y2").value)
        const x = parseFloat(document.getElementById("x").value)

        // Calculate interpolated y value
        const y = y1 + ((x - x1) * (y2 - y1)) / (x2 - x1)

        // Calculate shape functions
        const N1 = (x2 - x) / (x2 - x1)
        const N2 = (x - x1) / (x2 - x1)

        // Calculate shape function interpolation components
        const y1_N1 = y1 * N1
        const y2_N2 = y2 * N2
        const y_sum = y1_N1 + y2_N2

        // Calculate bounds
        const bounds = calculateBounds(x1, y1, x2, y2, x)

        // Clear and recreate boards with new bounds
        if (interpolationBoard) {
          JXG.JSXGraph.freeBoard(interpolationBoard)
        }
        if (shapeFunctionsBoard) {
          JXG.JSXGraph.freeBoard(shapeFunctionsBoard)
        }
        if (interpolationShapeBoard) {
          JXG.JSXGraph.freeBoard(interpolationShapeBoard)
        }

        // Board configuration with fixed elements
        const boardConfig = {
          showCopyright: false,
          showNavigation: false,
          grid: false,
          axis: true
        }

        // Create interpolation board
        interpolationBoard = JXG.JSXGraph.initBoard("interpolationCanvas1", {
          ...boardConfig,
          boundingbox: bounds.interpolation
        })

        // Create shape functions board
        shapeFunctionsBoard = JXG.JSXGraph.initBoard("shapeFunctionsCanvas", {
          ...boardConfig,
          boundingbox: bounds.shapeFunction
        })

        // Create interpolation with shape function board
        interpolationShapeBoard = JXG.JSXGraph.initBoard("interpolationShapeCanvas", {
          ...boardConfig,
          boundingbox: bounds.interpolation
        })

        // Draw interpolation graph
        // First create points
        point1 = interpolationBoard.create("point", [x1, y1], {
          name: `(${x1}, ${y1})`,
          size: 4,
          color: "#e74c3c",
          label: { offset: [10, 10] },
          fixed: true
        })

        point2 = interpolationBoard.create("point", [x2, y2], {
          name: `(${x2}, ${y2})`,
          size: 4,
          color: "#e74c3c",
          label: { offset: [10, 10] },
          fixed: true
        })

        // Draw infinite line (background, dashed)
        infiniteLine = interpolationBoard.create("line", [point1, point2], {
          strokeColor: "#bdc3c7",
          strokeWidth: 1,
          dash: 2,
          fixed: true
        })

        // Draw line segment (foreground, solid)
        lineSegment = interpolationBoard.create("segment", [point1, point2], {
          strokeColor: "#3498db",
          strokeWidth: 3,
          fixed: true
        })

        interpolatedPoint = interpolationBoard.create("point", [x, y], {
          name: `(${x.toFixed(2)}, ${y.toFixed(2)})`,
          size: 4,
          color: "#2ecc71",
          label: { offset: [10, 10] },
          fixed: true
        })

        // Draw shape functions graph
        shapeLine1 = shapeFunctionsBoard.create(
          "functiongraph",
          [
            function (t) {
              return (x2 - t) / (x2 - x1)
            },
            x1,
            x2
          ],
          {
            name: "N1(x)",
            strokeColor: "#e74c3c",
            strokeWidth: 2,
            fixed: true
          }
        )

        shapeLine2 = shapeFunctionsBoard.create(
          "functiongraph",
          [
            function (t) {
              return (t - x1) / (x2 - x1)
            },
            x1,
            x2
          ],
          {
            name: "N2(x)",
            strokeColor: "#3498db",
            strokeWidth: 2,
            fixed: true
          }
        )

        shapePoint1 = shapeFunctionsBoard.create("point", [x, N1], {
          name: `N1(${x}) = ${N1.toFixed(2)}`,
          size: 4,
          color: "#e74c3c",
          label: { offset: [10, 10] },
          fixed: true
        })

        shapePoint2 = shapeFunctionsBoard.create("point", [x, N2], {
          name: `N2(${x}) = ${N2.toFixed(2)}`,
          size: 4,
          color: "#3498db",
          label: { offset: [10, 10] },
          fixed: true
        })

        // Add dashed vertical lines at x1 and x2 in shape functions canvas
        shapeFunctionsBoard.create(
          "line",
          [
            [x1, -0.5],
            [x1, 1.5]
          ],
          {
            strokeColor: "#95a5a6",
            strokeWidth: 1,
            dash: 2,
            fixed: true
          }
        )

        shapeFunctionsBoard.create(
          "line",
          [
            [x2, -0.5],
            [x2, 1.5]
          ],
          {
            strokeColor: "#95a5a6",
            strokeWidth: 1,
            dash: 2,
            fixed: true
          }
        )

        // Add formula text to shape functions canvas
        shapeFunctionsBoard.create("text", [bounds.shapeFunction[0] + (bounds.shapeFunction[2] - bounds.shapeFunction[0]) * 0.05, bounds.shapeFunction[1] - 0.2, `y = ${N1.toFixed(2)} * ${y1} + ${N2.toFixed(2)} * ${y2} = ${y.toFixed(2)}`], {
          fontSize: 12,
          color: "#2c3e50",
          fixed: true
        })

        // Draw interpolation with shape function graph
        // Component 1: y1 * N1
        shapeInterpolationComponents = interpolationShapeBoard.create(
          "functiongraph",
          [
            function (t) {
              const n1 = (x2 - t) / (x2 - x1)
              return y1 * n1
            },
            x1,
            x2
          ],
          {
            name: "y1*N1(x)",
            strokeColor: "#e74c3c",
            strokeWidth: 2,
            dash: 1,
            fixed: true
          }
        )

        // Component 2: y2 * N2
        interpolationShapeBoard.create(
          "functiongraph",
          [
            function (t) {
              const n2 = (t - x1) / (x2 - x1)
              return y2 * n2
            },
            x1,
            x2
          ],
          {
            name: "y2*N2(x)",
            strokeColor: "#3498db",
            strokeWidth: 2,
            dash: 1,
            fixed: true
          }
        )

        // Sum: y1*N1 + y2*N2
        shapeInterpolationSum = interpolationShapeBoard.create(
          "functiongraph",
          [
            function (t) {
              const n1 = (x2 - t) / (x2 - x1)
              const n2 = (t - x1) / (x2 - x1)
              return y1 * n1 + y2 * n2
            },
            x1,
            x2
          ],
          {
            name: "y1*N1(x) + y2*N2(x)",
            strokeColor: "#2ecc71",
            strokeWidth: 3,
            fixed: true
          }
        )

        // Add dashed vertical lines at x1 and x2 in interpolation with shape function canvas
        interpolationShapeBoard.create(
          "line",
          [
            [x1, bounds.interpolation[3]],
            [x1, bounds.interpolation[1]]
          ],
          {
            strokeColor: "#95a5a6",
            strokeWidth: 1,
            dash: 2,
            fixed: true
          }
        )

        interpolationShapeBoard.create(
          "line",
          [
            [x2, bounds.interpolation[3]],
            [x2, bounds.interpolation[1]]
          ],
          {
            strokeColor: "#95a5a6",
            strokeWidth: 1,
            dash: 2,
            fixed: true
          }
        )

        // Add points at x1 and x2 for shape interpolation
        interpolationShapeBoard.create("point", [x1, y1], {
          name: `(${x1}, ${y1})`,
          size: 4,
          color: "#e74c3c",
          label: { offset: [10, 10] },
          fixed: true
        })

        interpolationShapeBoard.create("point", [x2, y2], {
          name: `(${x2}, ${y2})`,
          size: 4,
          color: "#3498db",
          label: { offset: [10, 10] },
          fixed: true
        })

        // Add interpolated point
        interpolationShapeBoard.create("point", [x, y_sum], {
          name: `(${x.toFixed(2)}, ${y_sum.toFixed(2)})`,
          size: 4,
          color: "#2ecc71",
          label: { offset: [10, 10] },
          fixed: true
        })
      }

      // Initialize graphs on page load
      document.addEventListener("DOMContentLoaded", updateGraphs)
    </script>
  </head>
  <body>
    <header>
      <h1 style="color: white">Basic Math Review for FEM</h1>
      <nav>
        <ul>
          <li><a href="#vectors" class="tab-link active">Vectors</a></li>
          <li><a href="#matrices" class="tab-link">Matrices</a></li>
          <li><a href="#interpolation" class="tab-link">Interpolation</a></li>
          <li><a href="#differentiation" class="tab-link">Differentiation</a></li>
          <li><a href="#integration" class="tab-link">Integration</a></li>
        </ul>
      </nav>
    </header>

    <div id="main-content">
      <section id="vectors" class="tab-content active">
        <h1>Vectors</h1>
        <p>A vector in n-dimensional space is an ordered collection of n numbers. We denote vectors using curly braces { }. For an n-dimensional vector {a}, we write:</p>
        <p class="math-formula">{a} = {a₁, a₂, ..., aₙ}</p>
        <p>where a₁, a₂, ..., aₙ are the components of the vector {a}.</p>

        <h2>The Zero Vector</h2>
        <p>The zero vector, denoted as {0}, is a special vector where all components are zero:</p>
        <p class="math-formula">{0} = {0, 0, ..., 0}</p>
        <p>The zero vector plays a crucial role in vector operations, as we'll see below.</p>

        <h2>Vector Operations</h2>

        <div class="important-note">Note: Vector operations such as addition, subtraction, and scalar multiplication are only permitted for vectors of the same dimension.</div>

        <h3>1. Vector Addition</h3>
        <p>For two vectors {a} and {b} in n-dimensional space, their sum {c} = {a} + {b} is defined as:</p>
        <p class="math-formula">{c} = {a₁+b₁, a₂+b₂, ..., aₙ+bₙ}</p>

        <div class="zero-vector-note">
          If one of the vectors is the zero vector, e.g., {b} = {0}, then:
          <p class="math-formula">{a} + {0} = {a}</p>
          Adding the zero vector to any vector results in the same vector.
        </div>

        <h3>2. Vector Subtraction</h3>
        <p>For two vectors {a} and {b} in n-dimensional space, their difference {d} = {a} - {b} is defined as:</p>
        <p class="math-formula">{d} = {a₁-b₁, a₂-b₂, ..., aₙ-bₙ}</p>

        <div class="zero-vector-note">
          If one of the vectors is the zero vector, e.g., {b} = {0}, then:
          <p class="math-formula">{a} - {0} = {a}</p>
          Subtracting the zero vector from any vector results in the same vector.
        </div>

        <h3>3. Scalar Multiplication</h3>
        <p>For a vector {a} and a scalar k, their product {p} = k{a} is defined as:</p>
        <p class="math-formula">{p} = {ka₁, ka₂, ..., kaₙ}</p>

        <div class="zero-vector-note">
          If the vector is the zero vector, i.e., {a} = {0}, then for any scalar k:
          <p class="math-formula">k{0} = {0}</p>
          Multiplying the zero vector by any scalar results in the zero vector.
        </div>

        <h3>4. Dot Product</h3>
        <p>For two vectors {a} and {b} in n-dimensional space, their dot product is a scalar defined as:</p>
        <p class="math-formula">{a} · {b} = a₁b₁ + a₂b₂ + ... + aₙbₙ</p>

        <div class="zero-vector-note">
          If one of the vectors is the zero vector, e.g., {b} = {0}, then:
          <p class="math-formula">{a} · {0} = 0</p>
          The dot product of any vector with the zero vector is always zero.
        </div>

        <h3>5. Vector Norm (Magnitude)</h3>
        <p>The norm or magnitude of a vector {a}, denoted as ||{a}||, is defined as:</p>
        <p class="math-formula">||{a}|| = √(a₁² + a₂² + ... + aₙ²)</p>

        <div class="zero-vector-note">
          For the zero vector {0}:
          <p class="math-formula">||{0}|| = 0</p>
          The norm of the zero vector is always zero.
        </div>

        <h2>Properties of Vector Operations</h2>
        <div class="properties-section">
          <p>Vector operations have several important properties. Let {a}, {b}, and {c} be vectors in n-dimensional space, and k and m be scalars:</p>

          <div class="property">
            <p class="property-name">1. Commutativity of Addition:</p>
            <p class="math-formula">{a} + {b} = {b} + {a}</p>
          </div>

          <div class="property">
            <p class="property-name">2. Associativity of Addition:</p>
            <p class="math-formula">({a} + {b}) + {c} = {a} + ({b} + {c})</p>
          </div>

          <div class="property">
            <p class="property-name">3. Additive Identity:</p>
            <p class="math-formula">{a} + {0} = {a}</p>
          </div>

          <div class="property">
            <p class="property-name">4. Additive Inverse:</p>
            <p class="math-formula">{a} + (-{a}) = {0}</p>
          </div>

          <div class="property">
            <p class="property-name">5. Distributivity of Scalar Multiplication over Vector Addition:</p>
            <p class="math-formula">k({a} + {b}) = k{a} + k{b}</p>
          </div>

          <div class="property">
            <p class="property-name">6. Distributivity of Vector Addition over Scalar Multiplication:</p>
            <p class="math-formula">(k + m){a} = k{a} + m{a}</p>
          </div>

          <div class="property">
            <p class="property-name">7. Associativity of Scalar Multiplication:</p>
            <p class="math-formula">k(m{a}) = (km){a}</p>
          </div>

          <div class="property">
            <p class="property-name">8. Scalar Multiplication Identity:</p>
            <p class="math-formula">1{a} = {a}</p>
          </div>

          <div class="property">
            <p class="property-name">9. Distributivity of Dot Product over Addition:</p>
            <p class="math-formula">{a} · ({b} + {c}) = {a} · {b} + {a} · {c}</p>
          </div>

          <div class="property">
            <p class="property-name">10. Commutativity of Dot Product:</p>
            <p class="math-formula">{a} · {b} = {b} · {a}</p>
          </div>

          <div class="property">
            <p class="property-name">11. Scalar Multiplication and Dot Product:</p>
            <p class="math-formula">(k{a}) · {b} = k({a} · {b}) = {a} · (k{b})</p>
          </div>

          <div class="property">
            <p class="property-name">12. Norm and Scalar Multiplication:</p>
            <p class="math-formula">||k{a}|| = |k| ||{a}||</p>
          </div>
        </div>

        <h2>Interactive Vector Operations Demo</h2>
        <div class="interactive-demo">
          <label for="dimension-input">Enter the dimension of the vectors: </label>
          <input type="number" id="dimension-input" min="1" max="10" value="3" />
          <button onclick="generateVectors()">Generate Vectors</button>
          <div id="vector-display"></div>
          <button onclick="addVectors()">Add Vectors</button>
          <button onclick="subtractVectors()">Subtract Vectors</button>
          <button onclick="multiplyByScalar()">Multiply by Scalar</button>
          <button onclick="calculateDotProduct()">Calculate Dot Product</button>
          <button onclick="calculateNorm()">Calculate Norm</button>
          <div id="result-display"></div>
          <div class="calculation-steps" id="calculation-steps"></div>
        </div>
      </section>

      <section id="matrices" class="tab-content">
        <h1>Matrices</h1>
        <h2>Introduction to Matrices</h2>
        <p>A matrix is a rectangular array of numbers, symbols, or expressions arranged in rows and columns. We denote matrices using capital letters enclosed in curly braces. For an m × n matrix {A}, we write:</p>
        <div class="math-formula">
          {A} =
          <table>
            <tr>
              <td>a₁₁</td>
              <td>a₁₂</td>
              <td>...</td>
              <td>a₁ₙ</td>
            </tr>
            <tr>
              <td>a₂₁</td>
              <td>a₂₂</td>
              <td>...</td>
              <td>a₂ₙ</td>
            </tr>
            <tr>
              <td>...</td>
              <td>...</td>
              <td>...</td>
              <td>...</td>
            </tr>
            <tr>
              <td>aₘ₁</td>
              <td>aₘ₂</td>
              <td>...</td>
              <td>aₘₙ</td>
            </tr>
          </table>
        </div>
        <p>where aᵢⱼ represents the element in the i-th row and j-th column of {A}.</p>

        <h2>The Zero Matrix</h2>
        <p>The zero matrix, denoted as {0}, is a special matrix where all elements are zero:</p>
        <div class="math-formula">
          {0} =
          <table>
            <tr>
              <td>0</td>
              <td>0</td>
              <td>...</td>
              <td>0</td>
            </tr>
            <tr>
              <td>0</td>
              <td>0</td>
              <td>...</td>
              <td>0</td>
            </tr>
            <tr>
              <td>...</td>
              <td>...</td>
              <td>...</td>
              <td>...</td>
            </tr>
            <tr>
              <td>0</td>
              <td>0</td>
              <td>...</td>
              <td>0</td>
            </tr>
          </table>
        </div>
        <p>The zero matrix plays a crucial role in matrix operations, as we'll see below.</p>

        <h2>Matrix Operations</h2>

        <div class="important-note">Note: Matrix operations such as addition and multiplication are only permitted for matrices of compatible dimensions.</div>

        <h3>1. Matrix Addition</h3>
        <p>For two matrices {A} and {B} of the same dimensions (m × n), their sum {C} = {A} + {B} is defined as:</p>
        <p class="math-formula">cᵢⱼ = aᵢⱼ + bᵢⱼ for all i and j</p>

        <div class="zero-matrix-note">
          If one of the matrices is the zero matrix, e.g., {B} = {0}, then:
          <p class="math-formula">{A} + {0} = {A}</p>
          Adding the zero matrix to any matrix results in the same matrix.
        </div>

        <h3>2. Matrix Subtraction</h3>
        <p>For two matrices {A} and {B} of the same dimensions (m × n), their difference {D} = {A} - {B} is defined as:</p>
        <p class="math-formula">dᵢⱼ = aᵢⱼ - bᵢⱼ for all i and j</p>

        <div class="zero-matrix-note">
          If one of the matrices is the zero matrix, e.g., {B} = {0}, then:
          <p class="math-formula">{A} - {0} = {A}</p>
          Subtracting the zero matrix from any matrix results in the same matrix.
        </div>

        <h3>3. Scalar Multiplication</h3>
        <p>For a matrix {A} and a scalar k, their product {P} = k{A} is defined as:</p>
        <p class="math-formula">pᵢⱼ = k * aᵢⱼ for all i and j</p>

        <div class="zero-matrix-note">
          If the matrix is the zero matrix, i.e., {A} = {0}, then for any scalar k:
          <p class="math-formula">k{0} = {0}</p>
          Multiplying the zero matrix by any scalar results in the zero matrix.
        </div>

        <h3>4. Matrix Multiplication</h3>
        <p>For an m × n matrix {A} and an n × p matrix {B}, their product {C} = {A}{B} is an m × p matrix defined as:</p>
        <p class="math-formula">cᵢⱼ = Σ(k=1 to n) aᵢₖ * bₖⱼ for all i and j</p>

        <div class="zero-matrix-note">
          If one of the matrices is the zero matrix, e.g., {B} = {0}, then:
          <p class="math-formula">{A}{0} = {0} and {0}{A} = {0}</p>
          Multiplying any matrix by the zero matrix results in the zero matrix.
        </div>

        <h3>5. Matrix Transpose</h3>
        <p>The transpose of an m × n matrix {A}, denoted as {A}ᵀ, is an n × m matrix where:</p>
        <p class="math-formula">({A}ᵀ)ᵢⱼ = aⱼᵢ for all i and j</p>

        <div class="zero-matrix-note">
          For the zero matrix {0}:
          <p class="math-formula">{0}ᵀ = {0}</p>
          The transpose of the zero matrix is the zero matrix.
        </div>

        <h2>Properties of Matrix Operations</h2>
        <div class="properties-section">
          <p>Matrix operations have several important properties. Let {A}, {B}, and {C} be matrices of compatible dimensions, and k and m be scalars:</p>

          <div class="property">
            <p class="property-name">1. Commutativity of Addition:</p>
            <p class="math-formula">{A} + {B} = {B} + {A}</p>
          </div>

          <div class="property">
            <p class="property-name">2. Associativity of Addition:</p>
            <p class="math-formula">({A} + {B}) + {C} = {A} + ({B} + {C})</p>
          </div>

          <div class="property">
            <p class="property-name">3. Additive Identity:</p>
            <p class="math-formula">{A} + {0} = {A}</p>
          </div>

          <div class="property">
            <p class="property-name">4. Additive Inverse:</p>
            <p class="math-formula">{A} + (-{A}) = {0}</p>
          </div>

          <div class="property">
            <p class="property-name">5. Distributivity of Scalar Multiplication over Matrix Addition:</p>
            <p class="math-formula">k({A} + {B}) = k{A} + k{B}</p>
          </div>

          <div class="property">
            <p class="property-name">6. Distributivity of Matrix Addition over Scalar Multiplication:</p>
            <p class="math-formula">(k + m){A} = k{A} + m{A}</p>
          </div>

          <div class="property">
            <p class="property-name">7. Associativity of Scalar Multiplication:</p>
            <p class="math-formula">k(m{A}) = (km){A}</p>
          </div>

          <div class="property">
            <p class="property-name">8. Scalar Multiplication Identity:</p>
            <p class="math-formula">1{A} = {A}</p>
          </div>

          <div class="property">
            <p class="property-name">9. Distributivity of Matrix Multiplication over Addition:</p>
            <p class="math-formula">{A}({B} + {C}) = {A}{B} + {A}{C} and ({B} + {C}){A} = {B}{A} + {C}{A}</p>
          </div>

          <div class="property">
            <p class="property-name">10. Associativity of Matrix Multiplication:</p>
            <p class="math-formula">({A}{B}){C} = {A}({B}{C})</p>
          </div>

          <div class="property">
            <p class="property-name">11. Non-commutativity of Matrix Multiplication:</p>
            <p class="math-formula">{A}{B} ≠ {B}{A} (in general)</p>
          </div>

          <div class="property">
            <p class="property-name">12. Transpose of Sum:</p>
            <p class="math-formula">({A} + {B})ᵀ = {A}ᵀ + {B}ᵀ</p>
          </div>

          <div class="property">
            <p class="property-name">13. Transpose of Product:</p>
            <p class="math-formula">({A}{B})ᵀ = {B}ᵀ{A}ᵀ</p>
          </div>

          <div class="property">
            <p class="property-name">14. Transpose of Scalar Multiple:</p>
            <p class="math-formula">(k{A})ᵀ = k{A}ᵀ</p>
          </div>
        </div>

        <h2>Interactive Matrix Operations Demo</h2>
        <div class="interactive-demo">
          <div>
            <label for="rows-a">Rows for Matrix {A}: </label>
            <input type="number" id="rows-a" min="1" max="5" value="2" />
            <label for="cols-a">Columns for Matrix {A}: </label>
            <input type="number" id="cols-a" min="1" max="5" value="2" />
          </div>
          <div>
            <label for="rows-b">Rows for Matrix {B}: </label>
            <input type="number" id="rows-b" min="1" max="5" value="2" />
            <label for="cols-b">Columns for Matrix {B}: </label>
            <input type="number" id="cols-b" min="1" max="5" value="2" />
          </div>
          <button onclick="generateMatrices()">Generate Matrices</button>
          <div id="matrix-display"></div>
          <button onclick="addMatrices()">Add Matrices</button>
          <button onclick="subtractMatrices()">Subtract Matrices</button>
          <button onclick="multiplyByScalarM()">Multiply by Scalar</button>
          <button onclick="multiplyMatrices()">Multiply Matrices</button>
          <button onclick="transposeMatrix()">Transpose Matrix {A}</button>
          <div id="result-displayM"></div>
          <div class="calculation-steps" id="calculation-stepsM"></div>
        </div>

        <script>
          let matrixA, matrixB

          function generateMatrices() {
            document.getElementById("calculation-stepsM").innerHTML = ""
            document.getElementById("result-display").innerHTML = ""
            const rowsA = parseInt(document.getElementById("rows-a").value)
            const colsA = parseInt(document.getElementById("cols-a").value)
            const rowsB = parseInt(document.getElementById("rows-b").value)
            const colsB = parseInt(document.getElementById("cols-b").value)

            matrixA = Array.from({ length: rowsA }, () => Array.from({ length: colsA }, () => Math.floor(Math.random() * 10) - 5))
            matrixB = Array.from({ length: rowsB }, () => Array.from({ length: colsB }, () => Math.floor(Math.random() * 10) - 5))

            displayMatrices()
          }

          function displayMatrices() {
            const matrixDisplay = document.getElementById("matrix-display")
            matrixDisplay.innerHTML = `
                <h3>Matrix {A}:</h3>
                ${matrixToHtml(matrixA)}
                <h3>Matrix {B}:</h3>
                ${matrixToHtml(matrixB)}
            `
          }

          function matrixToHtml(matrix) {
            return `
                <table>
                    ${matrix
                      .map(
                        row => `
                        <tr>${row.map(cell => `<td>${cell}</td>`).join("")}</tr>
                    `
                      )
                      .join("")}
                </table>
            `
          }

          function addMatrices() {
            if (!matrixA || !matrixB || matrixA.length !== matrixB.length || matrixA[0].length !== matrixB[0].length) {
              alert("Matrices must have the same dimensions for addition.")
              return
            }
            const result = matrixA.map((row, i) => row.map((cell, j) => cell + matrixB[i][j]))
            displayResultM("{A} + {B}", result)
            displayCalculationStepsM("Addition", matrixA, matrixB, result)
          }

          function subtractMatrices() {
            if (!matrixA || !matrixB || matrixA.length !== matrixB.length || matrixA[0].length !== matrixB[0].length) {
              alert("Matrices must have the same dimensions for subtraction.")
              return
            }
            const result = matrixA.map((row, i) => row.map((cell, j) => cell - matrixB[i][j]))
            displayResultM("{A} - {B}", result)
            displayCalculationStepsM("Subtraction", matrixA, matrixB, result)
          }

          function multiplyByScalarM() {
            if (!matrixA) {
              alert("Please generate matrices first.")
              return
            }
            const scalar = parseFloat(prompt("Enter a scalar value:"))
            if (isNaN(scalar)) {
              alert("Please enter a valid number.")
              return
            }
            const result = matrixA.map(row => row.map(cell => cell * scalar))
            displayResultM(`${scalar}{A}`, result)
            displayCalculationStepsM("Scalar Multiplication", matrixA, [scalar], result)
          }

          function multiplyMatrices() {
            if (!matrixA || !matrixB || matrixA[0].length !== matrixB.length) {
              alert("Number of columns in {A} must equal number of rows in {B} for matrix multiplication.")
              return
            }
            const result = matrixA.map((row, i) => matrixB[0].map((_, j) => row.reduce((sum, cell, k) => sum + cell * matrixB[k][j], 0)))
            displayResultM("{A}{B}", result)
            displayCalculationStepsM("Matrix Multiplication", matrixA, matrixB, result)
          }

          function transposeMatrix() {
            if (!matrixA) {
              alert("Please generate matrices first.")
              return
            }
            const result = matrixA[0].map((_, i) => matrixA.map(row => row[i]))
            displayResultM("{A}ᵀ", result)
            displayCalculationSteps("TransposeM", matrixA, null, result)
          }

          function displayResultM(operation, result) {
            const resultDisplay = document.getElementById("result-displayM")
            resultDisplay.innerHTML = `
                <h3>${operation}:</h3>
                ${matrixToHtml(result)}
            `
          }

          function displayCalculationStepsM(operation, matrix1, matrix2, result) {
            const stepsDisplay = document.getElementById("calculation-stepsM")
            let steps = `<h3>${operation} Calculation Steps:</h3>`

            switch (operation) {
              case "Addition":
              case "Subtraction":
                steps += matrix1.map((row, i) => row.map((cell, j) => `<div class="step">(${i + 1},${j + 1}): ${cell} ${operation === "Addition" ? "+" : "-"} ${matrix2[i][j]} = ${result[i][j]}</div>`).join("")).join("")
                break
              case "Scalar Multiplication":
                steps += matrix1.map((row, i) => row.map((cell, j) => `<div class="step">(${i + 1},${j + 1}): ${matrix2[0]} * ${cell} = ${result[i][j]}</div>`).join("")).join("")
                break
              case "Matrix Multiplication":
                steps += result
                  .map((row, i) =>
                    row
                      .map((cell, j) => {
                        let stepCalc = `<div class="step">(${i + 1},${j + 1}): `
                        stepCalc += matrix1[i].map((_, k) => `(${matrix1[i][k]} * ${matrix2[k][j]})`).join(" + ")
                        stepCalc += ` = ${cell}</div>`
                        return stepCalc
                      })
                      .join("")
                  )
                  .join("")
                break
              case "Transpose":
                steps += result.map((row, i) => row.map((cell, j) => `<div class="step">(${i + 1},${j + 1}) of {A}ᵀ = (${j + 1},${i + 1}) of {A} = ${cell}</div>`).join("")).join("")
                break
            }

            stepsDisplay.innerHTML = steps
          }
        </script>
      </section>

      <section id="interpolation" class="tab-content">
        <div id="linear">
          <h1>1. Linear Interpolation</h1>

          <section id="introduction">
            <h3>What is Linear Interpolation?</h3>
            <p>Linear interpolation is a method of estimating a value between two known values. It assumes a straight line between these two points and finds the desired point along that line.</p>
          </section>

          <section id="formula">
            <h3>The Formula</h3>
            <p>The formula for linear interpolation is:</p>
            <p><strong>y = y1 + (x - x1) * (y2 - y1) / (x2 - x1)</strong></p>
            <p>Where:</p>
            <ul>
              <li>(x1, y1) is the first known point</li>
              <li>(x2, y2) is the second known point</li>
              <li>x is the x-coordinate of the point we want to find</li>
              <li>y is the resulting y-coordinate</li>
            </ul>
          </section>

          <section id="visualization">
            <h3>Interactive Visualization</h3>

            <div class="input-group">
              <div class="point-group">
                <h4>Point 1:</h4>
                <label for="x1">x1:</label>
                <input class="interp-inputs" type="number" id="x1" value="100" />
                <label for="y1">y1:</label>
                <input class="interp-inputs" type="number" id="y1" value="100" />
              </div>
              <div class="point-group">
                <h4>Point 2:</h4>
                <label for="x2">x2:</label>
                <input class="interp-inputs" type="number" id="x2" value="400" />
                <label for="y2">y2:</label>
                <input class="interp-inputs" type="number" id="y2" value="300" />
              </div>
              <div class="x-group">
                <h4>Interpolate at:</h4>
                <label for="x">x:</label>
                <input class="interp-inputs" type="number" id="x" value="200" />
              </div>
              <button class="update-button" onclick="updateGraphs()">Update Graphs</button>
            </div>
            <div class="canvas-container">
              <div class="canvas-item">
                <div id="interpolationCanvas1" class="jxgbox" style="width: 600px; height: 350px"></div>
              </div>
              <div class="canvas-item">
                <h3>Shape Functions</h3>
                <div id="shapeFunctionsCanvas" class="jxgbox" style="width: 600px; height: 350px"></div>
              </div>
              <div class="canvas-item">
                <h3>Interpolation with Shape Functions</h3>
                <div id="interpolationShapeCanvas" class="jxgbox" style="width: 600px; height: 350px"></div>
              </div>
            </div>
          </section>
        </div>
        <div id="lagrange" style="padding-top: 50px">
          <h1>2. Lagrange Interpolation</h1>

          <p>Edit the number of points and their x, y values to see how the Lagrange interpolation and individual polynomials change. The first and last points will rediv fixed and are not editable.</p>

          <div class="controls">
            <label for="numPoints">Number of Points:</label>
            <input type="number" id="numPoints" min="2" max="10" value="3" />
            <button id="updatePoints">Update Points</button>
          </div>

          <h2>Point Data</h2>
          <table id="pointTable">
            <thead>
              <tr>
                <th>Point</th>
                <th>X</th>
                <th>Y</th>
              </tr>
            </thead>
            <tbody>
              <!-- Point data will be inserted here -->
            </tbody>
          </table>

          <div id="canvasContainer">
            <div>
              <h2>Individual Polynomials</h2>
              <canvas id="polynomialsCanvas" width="900" height="400"></canvas>
            </div>
          </div>
          <div id="canvasContainer">
            <div>
              <h2>Full Interpolation</h2>
              <canvas id="interpolationCanvas" width="900" height="400"></canvas>
            </div>
          </div>
        </div>
      </section>

      <section id="differentiation" class="tab-content">
        <h2>Differentiation</h2>
        <p>Content will be added.</p>
      </section>

      <section id="integration" class="tab-content">
        <h1>Integration</h1>
        <div id="integration1D">
          <h2>Gauss-Legendre Quadrature</h2>
          <p>Explore Gauss-Legendre integration by changing the number of points and the integration interval.</p>

          <div class="input-section">
            <div class="input-group-int">
              <label for="functionInput1D">Function f(x):</label>
              <input type="text" id="functionInput1D" value="" />
            </div>
            <div class="input-group-int">
              <label for="intervalA1D">Interval [a, b]:</label>
              <input type="number" id="intervalA1D" value="0" step="0.1" />
              <input type="number" id="intervalB1D" value="3.1415926535" step="0.1" />
            </div>
            <div class="input-group-int">
              <label for="numPoints1D">Number of Gauss Points:</label>
              <select id="numPoints1D">
                <option value="1">1 Point</option>
                <option value="2" selected>2 Points</option>
                <option value="3">3 Points</option>
                <option value="4">4 Points</option>
              </select>
            </div>
            <button id="calculateButton1D">Calculate & Plot</button>
          </div>

          <div class="results-section">
            <h2>Results</h2>
            <p>Calculated Integral (Gauss): <span id="gaussResult1D"></span></p>
            <p>Calculated Integral (Exact): <span id="exactResult1D"></span></p>
            <p>Difference: <span id="differenceResult1D"></span></p>
            <h3>Interval Transformation:</h3>
            <p>Original interval <code>[a, b]</code> is transformed to <code>[-1, 1]</code> using:</p>
            <p><code>x = ((b - a)/2)t + ((b + a)/2)</code></p>
            <p><code>dx = ((b - a)/2) dt</code></p>
            <p>So, ∫<sub>a</sub><sup>b</sup> f(x) dx = ((b - a)/2) ∫<sub>-1</sub><sup>1</sup> f(((b - a)/2)t + ((b + a)/2)) dt</p>
            <p>
              Let <code>g(t) = f(((b - a)/2)t + ((b + a)/2))</code>. The integral becomes <code>((b - a)/2) Σ [w<sub>i</sub> × g(t<sub>i</sub>)]</code>
            </p>

            <h3>Gauss Points and Weights for t ∈ [-1, 1]:</h3>
            <div id="gaussPointsDisplay1D"></div>
          </div>

          <div class="canvas-section" style="display: flex; flex-direction: column">
            <div class="canvas-container">
              <h3>Original Function f(x) on [a, b]</h3>
              <canvas id="originalCanvas1D" width="600" height="300"></canvas>
            </div>
            <div class="canvas-container">
              <h3>Transformed Function g(t) on [-1, 1]</h3>
              <canvas id="transformedCanvas1D" width="600" height="300"></canvas>
            </div>
          </div>
        </div>
        <div id="integration2D">
          <h2>Gauss-Legendre Quadrature (2D)</h2>
          <p>Explore Gauss-Legendre integration for a two-variable function over a rectangular domain.</p>
          <div class="input-group-int2">
            <label for="functionInput2D">Function f(x, y):</label>
            <input type="text" id="functionInput2D" value="x^2 + y^3" />
          </div>
          <div class="input-section">
            <div class="input-group-int2">
              <label for="intervalA2D">x-Interval [a, b]:</label>
              <input type="number" id="intervalA2D" value="0" step="0.1" />
              <input type="number" id="intervalB2D" value="1" step="0.1" />
            </div>
            <div class="input-group-int2">
              <label for="intervalC2D">y-Interval [c, d]:</label>
              <input type="number" id="intervalC2D" value="0" step="0.1" />
              <input type="number" id="intervalD2D" value="2" step="0.1" />
            </div>
            <div class="input-group-int2">
              <label for="numPointsX2D">Gauss Points (x):</label>
              <select id="numPointsX2D">
                <option value="1">1 Point</option>
                <option value="2" selected>2 Points</option>
                <option value="3">3 Points</option>
                <option value="4">4 Points</option>
              </select>
            </div>
            <div class="input-group-int2">
              <label for="numPointsY2D">Gauss Points (y):</label>
              <select id="numPointsY2D">
                <option value="1">1 Point</option>
                <option value="2" selected>2 Points</option>
                <option value="3">3 Points</option>
                <option value="4">4 Points</option>
              </select>
            </div>
            <button id="calculateButton2D">Submit</button>
          </div>

          <div class="results-section">
            <h2>Results</h2>
            <p>Calculated Integral (Gauss): <span id="gaussResult2D"></span></p>
            <p>Calculated Integral (Exact): <span id="exactResult2D"></span></p>
            <p>Difference: <span id="differenceResult2D"></span></p>
            <h3>Interval Transformation:</h3>
            <p>The original integral over <code>[a, b] x [c, d]</code> is transformed to <code>[-1, 1] x [-1, 1]</code>.</p>
            <p>
              <code>x = ((b - a)/2)t<sub>x</sub> + ((b + a)/2)</code>
            </p>
            <p>
              <code>y = ((d - c)/2)t<sub>y</sub> + ((d + c)/2)</code>
            </p>
            <p>
              The integral becomes: <code>((b - a)/2)((d - c)/2) Σ<sub>i</sub> Σ<sub>j</sub> [w<sub>x,i</sub> w<sub>y,j</sub> × g(t<sub>x,i</sub>, t<sub>y,j</sub>)]</code>
            </p>

            <h3>Gauss Points, Weights, and Evaluation Points:</h3>
            <div id="gaussPointsDisplay2D"></div>
          </div>
        </div>
      </section>
    </div>
    <script>
      let vectorA, vectorB

      function generateVectors() {
        document.getElementById("calculation-steps").innerHTML = ""
        document.getElementById("result-display").innerHTML = ""
        const dimension = parseInt(document.getElementById("dimension-input").value)
        vectorA = Array.from({ length: dimension }, () => Math.floor(Math.random() * 10) - 5)
        vectorB = Array.from({ length: dimension }, () => Math.floor(Math.random() * 10) - 5)
        displayVectors()
      }

      function displayVectors() {
        const vectorDisplay = document.getElementById("vector-display")
        vectorDisplay.innerHTML = `
                <p>Vector A: {${vectorA.join(", ")}}</p>
                <p>Vector B: {${vectorB.join(", ")}}</p>
            `
      }

      function addVectors() {
        if (!vectorA || !vectorB) {
          alert("Please generate vectors first.")
          return
        }
        const result = vectorA.map((a, i) => a + vectorB[i])
        displayResult("A + B", result)
        displayCalculationSteps("Addition", vectorA, vectorB, result)
      }

      function subtractVectors() {
        if (!vectorA || !vectorB) {
          alert("Please generate vectors first.")
          return
        }
        const result = vectorA.map((a, i) => a - vectorB[i])
        displayResult("A - B", result)
        displayCalculationSteps("Subtraction", vectorA, vectorB, result)
      }

      function multiplyByScalar() {
        if (!vectorA) {
          alert("Please generate vectors first.")
          return
        }
        const scalar = parseFloat(prompt("Enter a scalar value:"))
        if (isNaN(scalar)) {
          alert("Please enter a valid number.")
          return
        }
        const result = vectorA.map(a => a * scalar)
        displayResult(`${scalar} * A`, result)
        displayCalculationSteps("Scalar Multiplication", vectorA, [scalar], result)
      }

      function calculateDotProduct() {
        if (!vectorA || !vectorB) {
          alert("Please generate vectors first.")
          return
        }
        const result = vectorA.reduce((sum, a, i) => sum + a * vectorB[i], 0)
        displayResult("A · B", [result])
        displayCalculationSteps("Dot Product", vectorA, vectorB, [result])
      }

      function calculateNorm() {
        if (!vectorA) {
          alert("Please generate vectors first.")
          return
        }
        const result = Math.sqrt(vectorA.reduce((sum, a) => sum + a * a, 0))
        displayResult("||A||", [result])
        displayCalculationSteps("Norm", vectorA, null, [result])
      }

      function displayResult(operation, result) {
        const resultDisplay = document.getElementById("result-display")
        resultDisplay.innerHTML = `<p>${operation} = {${result.join(", ")}}</p>`
      }

      function displayCalculationSteps(operation, vec1, vec2, result) {
        const stepsDisplay = document.getElementById("calculation-steps")

        // helper to format only inputs
        const formatInput = n => (n < 0 ? `(${n})` : n)

        let steps = `<h3>${operation} Calculation Steps:</h3>`

        switch (operation) {
          case "Addition":
          case "Subtraction":
            steps += vec1.map((v, i) => `<div class="step">Step ${i + 1}: ${formatInput(v)} ${operation === "Addition" ? "+" : "-"} ${formatInput(vec2[i])} = ${result[i]}</div>`).join("")
            break
          case "Scalar Multiplication":
            steps += vec1.map((v, i) => `<div class="step">Step ${i + 1}: ${vec2[0]} * ${formatInput(v)} = ${result[i]}</div>`).join("")
            break
          case "Dot Product":
            steps += vec1.map((v, i) => `<div class="step">Step ${i + 1}: ${formatInput(v)} * ${formatInput(vec2[i])} = ${v * vec2[i]}</div>`).join("")
            steps += `<div class="step">Final Step: Sum of products = ${result[0]}</div>`
            break
          case "Norm":
            steps += vec1.map((v, i) => `<div class="step">Step ${i + 1}: ${formatInput(v)}² = ${v * v}</div>`).join("")
            steps += `<div class="step">Sum of squares: ${vec1.reduce((sum, v) => sum + v * v, 0)}</div>`
            steps += `<div class="step">Final Step: Square root of sum = ${result[0]}</div>`
            break
        }

        stepsDisplay.innerHTML = steps
      }

      document.addEventListener("DOMContentLoaded", () => {
        const tabLinks = document.querySelectorAll(".tab-link")
        const tabContents = document.querySelectorAll(".tab-content")

        // Function to show a specific tab
        const showTab = tabId => {
          // Hide all tab contents
          tabContents.forEach(content => {
            content.classList.remove("active")
          })

          // Deactivate all tab links
          tabLinks.forEach(link => {
            link.classList.remove("active")
          })

          // Show the selected tab content
          const targetContent = document.querySelector(tabId)
          if (targetContent) {
            targetContent.classList.add("active")
          }

          // Activate the corresponding tab link
          const targetLink = document.querySelector(`a[href="${tabId}"]`)
          if (targetLink) {
            targetLink.classList.add("active")
          }
        }

        // Add event listeners to tab links
        tabLinks.forEach(link => {
          link.addEventListener("click", event => {
            event.preventDefault() // Prevent default anchor link behavior
            const tabId = event.target.getAttribute("href")
            showTab(tabId)
          })
        })

        // Handle initial tab display based on URL hash, or default to first tab
        const initialHash = window.location.hash
        if (initialHash && document.querySelector(initialHash)) {
          showTab(initialHash)
        } else {
          // Default to the first tab if no hash or invalid hash
          if (tabLinks.length > 0) {
            showTab(tabLinks[0].getAttribute("href"))
          }
        }
      })
    </script>
    <script>
      // Code for Lagrange Interpolation
      const interpolationCanvas = document.getElementById("interpolationCanvas")
      const polynomialsCanvas = document.getElementById("polynomialsCanvas")
      const ctxInterpolation = interpolationCanvas.getContext("2d")
      const ctxPolynomials = polynomialsCanvas.getContext("2d")
      const numPointsInput = document.getElementById("numPoints")
      const updatePointsBtn = document.getElementById("updatePoints")
      const pointTable = document.getElementById("pointTable").getElementsByTagName("tbody")[0]
      let points = []

      const colors = ["#e74c3c", "#3498db", "#2ecc71", "#f39c12", "#9b59b6", "#1abc9c", "#34495e", "#e67e22", "#95a5a6", "#16a085"]

      function drawPoint(ctx, x, y) {
        ctx.beginPath()
        ctx.arc(x, y, 4, 0, 2 * Math.PI)
        ctx.fillStyle = "red"
        ctx.fill()
      }

      function lagrangeInterpolation(x, points) {
        let result = 0
        for (let i = 0; i < points.length; i++) {
          result += points[i].y * lagrangeBasis(x, i, points)
        }
        return result
      }

      function lagrangeBasis(x, i, points) {
        let basis = 1
        for (let j = 0; j < points.length; j++) {
          if (i !== j) {
            basis *= (x - points[j].x) / (points[i].x - points[j].x)
          }
        }
        return basis
      }

      function getYRange(points, isPolynomials = false) {
        let yMin = Infinity
        let yMax = -Infinity

        for (let x = 0; x <= 10; x += 0.1) {
          if (isPolynomials) {
            for (let i = 0; i < points.length; i++) {
              const y = lagrangeBasis(x, i, points)
              yMin = Math.min(yMin, y)
              yMax = Math.max(yMax, y)
            }
          } else {
            const y = lagrangeInterpolation(x, points)
            yMin = Math.min(yMin, y)
            yMax = Math.max(yMax, y)
          }
        }

        // Add some padding
        const padding = (yMax - yMin) * 0.1
        return { yMin: yMin - padding, yMax: yMax + padding }
      }

      function drawInterpolation() {
        ctxInterpolation.clearRect(0, 0, interpolationCanvas.width, interpolationCanvas.height)
        const { yMin, yMax } = getYRange(points)
        const padding = 40
        const graphWidth = interpolationCanvas.width - padding * 2
        const graphHeight = interpolationCanvas.height - padding * 2

        // Draw x-axis
        ctxInterpolation.strokeStyle = "#000"
        ctxInterpolation.lineWidth = 1
        ctxInterpolation.beginPath()
        const yZero = interpolationCanvas.height - padding - ((0 - yMin) / (yMax - yMin)) * graphHeight
        ctxInterpolation.moveTo(padding, yZero)
        ctxInterpolation.lineTo(interpolationCanvas.width - padding, yZero)
        ctxInterpolation.stroke()

        // Draw y-axis
        ctxInterpolation.beginPath()
        ctxInterpolation.moveTo(padding, padding)
        ctxInterpolation.lineTo(padding, interpolationCanvas.height - padding)
        ctxInterpolation.stroke()

        // Draw points and interpolation
        points.forEach(point => {
          const x = padding + (point.x / 10) * graphWidth
          const y = interpolationCanvas.height - padding - ((point.y - yMin) / (yMax - yMin)) * graphHeight
          drawPoint(ctxInterpolation, x, y)

          // Draw x-value label
          ctxInterpolation.fillStyle = "#000"
          ctxInterpolation.font = "10px Arial"
          ctxInterpolation.textAlign = "center"
          ctxInterpolation.fillText(point.x.toFixed(1), x, yZero + 15)
        })

        if (points.length > 1) {
          ctxInterpolation.beginPath()
          for (let x = 0; x <= 10; x += 0.1) {
            const y = lagrangeInterpolation(x, points)
            const canvasX = padding + (x / 10) * graphWidth
            const canvasY = interpolationCanvas.height - padding - ((y - yMin) / (yMax - yMin)) * graphHeight
            if (x === 0) {
              ctxInterpolation.moveTo(canvasX, canvasY)
            } else {
              ctxInterpolation.lineTo(canvasX, canvasY)
            }
          }
          ctxInterpolation.strokeStyle = "blue"
          ctxInterpolation.lineWidth = 2
          ctxInterpolation.stroke()
        }

        // Draw y-axis labels
        ctxInterpolation.fillStyle = "#000"
        ctxInterpolation.font = "10px Arial"
        ctxInterpolation.textAlign = "right"
        ctxInterpolation.fillText(yMin.toFixed(1), padding - 5, interpolationCanvas.height - padding + 5)
        ctxInterpolation.fillText(yMax.toFixed(1), padding - 5, padding + 5)
      }

      function drawIndividualPolynomials() {
        ctxPolynomials.clearRect(0, 0, polynomialsCanvas.width, polynomialsCanvas.height)
        const { yMin, yMax } = getYRange(points, true)
        const padding = 40
        const graphWidth = polynomialsCanvas.width - padding * 2
        const graphHeight = polynomialsCanvas.height - padding * 2

        // Draw x-axis
        ctxPolynomials.strokeStyle = "#000"
        ctxPolynomials.lineWidth = 1
        ctxPolynomials.beginPath()
        const yZero = polynomialsCanvas.height - padding - ((0 - yMin) / (yMax - yMin)) * graphHeight
        ctxPolynomials.moveTo(padding, yZero)
        ctxPolynomials.lineTo(polynomialsCanvas.width - padding, yZero)
        ctxPolynomials.stroke()

        // Draw y-axis
        ctxPolynomials.beginPath()
        ctxPolynomials.moveTo(padding, padding)
        ctxPolynomials.lineTo(padding, polynomialsCanvas.height - padding)
        ctxPolynomials.stroke()

        // Draw points and individual polynomials
        points.forEach((point, index) => {
          const x = padding + (point.x / 10) * graphWidth
          const y = polynomialsCanvas.height - padding - ((point.y - yMin) / (yMax - yMin)) * graphHeight
          drawPoint(ctxPolynomials, x, y)

          // Draw x-value label
          ctxPolynomials.fillStyle = "#000"
          ctxPolynomials.font = "10px Arial"
          ctxPolynomials.textAlign = "center"
          ctxPolynomials.fillText(point.x.toFixed(1), x, yZero + 15)

          ctxPolynomials.beginPath()
          for (let x = 0; x <= 10; x += 0.1) {
            const y = lagrangeBasis(x, index, points)
            const canvasX = padding + (x / 10) * graphWidth
            const canvasY = polynomialsCanvas.height - padding - ((y - yMin) / (yMax - yMin)) * graphHeight
            if (x === 0) {
              ctxPolynomials.moveTo(canvasX, canvasY)
            } else {
              ctxPolynomials.lineTo(canvasX, canvasY)
            }
          }
          ctxPolynomials.strokeStyle = colors[index % colors.length]
          ctxPolynomials.lineWidth = 2
          ctxPolynomials.stroke()
        })

        // Draw y-axis labels
        ctxPolynomials.fillStyle = "#000"
        ctxPolynomials.font = "10px Arial"
        ctxPolynomials.textAlign = "right"
        ctxPolynomials.fillText(yMin.toFixed(1), padding - 5, polynomialsCanvas.height - padding + 5)
        ctxPolynomials.fillText(yMax.toFixed(1), padding - 5, padding + 5)
      }

      function updatePointTable() {
        pointTable.innerHTML = ""
        points.forEach((point, index) => {
          const row = pointTable.insertRow()
          row.insertCell(0).textContent = index + 1
          const xInput = document.createElement("input")
          xInput.type = "number"
          xInput.value = point.x
          xInput.min = 0
          xInput.max = 10
          xInput.step = 1
          xInput.addEventListener("change", e => {
            point.x = parseInt(e.target.value)
            drawInterpolation()
            drawIndividualPolynomials()
          })
          if (index === 0 || index === points.length - 1) {
            xInput.classList.add("readonly")
            xInput.readOnly = true
          }
          row.insertCell(1).appendChild(xInput)

          const yInput = document.createElement("input")
          yInput.type = "number"
          yInput.value = point.y.toFixed(2)
          yInput.step = 0.01
          yInput.addEventListener("change", e => {
            point.y = parseFloat(parseFloat(e.target.value).toFixed(2))
            drawInterpolation()
            drawIndividualPolynomials()
          })
          if (index === 0 || index === points.length - 1) {
            yInput.classList.add("readonly")
            yInput.readOnly = true
          }
          row.insertCell(2).appendChild(yInput)
        })
      }

      function initializePoints(num) {
        const oldPoints = [...points]
        points = []

        if (oldPoints.length > 0) {
          points.push({ x: 0, y: parseFloat(oldPoints[0].y.toFixed(2)) })
        } else {
          points.push({ x: 0, y: parseFloat((5 + Math.random() * 5 - 2.5).toFixed(2)) })
        }

        for (let i = 1; i < num - 1; i++) {
          points.push({
            x: Math.round((i * 10) / (num - 1)),
            y: parseFloat((5 + Math.random() * 5 - 2.5).toFixed(2))
          })
        }

        if (oldPoints.length > 1) {
          points.push({ x: 10, y: parseFloat(oldPoints[oldPoints.length - 1].y.toFixed(2)) })
        } else {
          points.push({ x: 10, y: parseFloat((5 + Math.random() * 5 - 2.5).toFixed(2)) })
        }

        updatePointTable()
        drawInterpolation()
        drawIndividualPolynomials()
      }

      updatePointsBtn.addEventListener("click", () => {
        const numPoints = parseInt(numPointsInput.value)
        if (numPoints >= 2 && numPoints <= 10) {
          initializePoints(numPoints)
        } else {
          alert("Please enter a number between 2 and 10")
        }
      })

      // Initialize with 3 points
      initializePoints(3)
    </script>
    <script>
      // CanvasPlotter Class
      class CanvasPlotter {
        constructor(canvasId) {
          this.canvas = document.getElementById(canvasId)
          if (!this.canvas) {
            console.error(`Canvas with ID "${canvasId}" not found.`)
            return
          }
          this.ctx = this.canvas.getContext("2d")
          this.xMin = 0
          this.xMax = 1
          this.yMin = 0
          this.yMax = 1

          this.padding = 30
          this.width = this.canvas.width - 2 * this.padding
          this.height = this.canvas.height - 2 * this.padding
        }

        setRange(xMin, xMax, yMin, yMax) {
          this.xMin = xMin
          this.xMax = xMax
          this.yMin = yMin
          this.yMax = yMax
        }

        toCanvasX(x) {
          return this.padding + ((x - this.xMin) / (this.xMax - this.xMin)) * this.width
        }

        toCanvasY(y) {
          return this.padding + (1 - (y - this.yMin) / (this.yMax - this.yMin)) * this.height
        }

        clear() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)
        }

        drawAxes(xLabel = "x", yLabel = "y") {
          this.ctx.strokeStyle = "#888"
          this.ctx.lineWidth = 1
          this.ctx.font = "10px Arial"
          this.ctx.fillStyle = "#333"

          // X-axis
          this.ctx.beginPath()
          this.ctx.moveTo(this.padding, this.toCanvasY(0))
          this.ctx.lineTo(this.padding + this.width, this.toCanvasY(0))
          this.ctx.stroke()

          // Y-axis
          this.ctx.beginPath()
          this.ctx.moveTo(this.toCanvasX(0), this.padding)
          this.ctx.lineTo(this.toCanvasX(0), this.padding + this.height)
          this.ctx.stroke()

          // X-axis labels
          this.ctx.textAlign = "center"
          this.ctx.textBaseline = "top"
          const numXLabels = 5
          for (let i = 0; i <= numXLabels; i++) {
            const xVal = this.xMin + (this.xMax - this.xMin) * (i / numXLabels)
            const px = this.toCanvasX(xVal)
            if (this.toCanvasY(0) + 5 > this.canvas.height - 10) {
              // Check if label would be too low
              this.ctx.fillText(xVal.toFixed(2), px, this.canvas.height - 15)
            } else {
              this.ctx.fillText(xVal.toFixed(2), px, this.toCanvasY(0) + 5)
            }
          }
          this.ctx.fillText(xLabel, this.padding + this.width / 2, this.canvas.height - 15)

          // Y-axis labels
          this.ctx.textAlign = "right"
          this.ctx.textBaseline = "middle"
          let labelX = this.xMin <= 0 && this.xMax >= 0 ? this.toCanvasX(0) - 5 : this.padding - 5
          const numYLabels = 5
          for (let i = 0; i <= numYLabels; i++) {
            const yVal = this.yMin + (this.yMax - this.yMin) * (i / numYLabels)
            const py = this.toCanvasY(yVal)
            this.ctx.fillText(yVal.toFixed(2), labelX, py)
          }

          this.ctx.save()
          this.ctx.translate(15, this.padding + this.height / 2)
          this.ctx.rotate(-Math.PI / 2)
          this.ctx.textAlign = "center"
          this.ctx.fillText(yLabel, 0, 0)
          this.ctx.restore()

          this.ctx.textAlign = "left"
          this.ctx.textBaseline = "top"
          let zeroLabelX = this.xMin <= 0 && this.xMax >= 0 ? this.toCanvasX(0) + 5 : this.padding + 5
          let zeroLabelY = this.yMin <= 0 && this.yMax >= 0 ? this.toCanvasY(0) + 5 : this.canvas.height - this.padding + 5
          this.ctx.fillText("0", zeroLabelX, zeroLabelY)
        }

        drawFunction(func, color = "blue", steps = 200) {
          this.ctx.strokeStyle = color
          this.ctx.lineWidth = 2
          this.ctx.beginPath()

          let firstPoint = true
          for (let i = 0; i <= steps; i++) {
            const x = this.xMin + (this.xMax - this.xMin) * (i / steps)
            const y = func(x)
            const px = this.toCanvasX(x)
            const py = this.toCanvasY(y)

            if (isFinite(y)) {
              if (firstPoint) {
                this.ctx.moveTo(px, py)
                firstPoint = false
              } else {
                this.ctx.lineTo(px, py)
              }
            } else {
              firstPoint = true
            }
          }
          this.ctx.stroke()
        }

        drawPoints(points, color = "red", radius = 4, showLines = true) {
          points.forEach(p => {
            const px = this.toCanvasX(p.x)
            const py = this.toCanvasY(p.y)

            this.ctx.fillStyle = color
            this.ctx.beginPath()
            this.ctx.arc(px, py, radius, 0, Math.PI * 2)
            this.ctx.fill()

            if (showLines) {
              this.ctx.strokeStyle = color
              this.ctx.lineWidth = 1
              this.ctx.setLineDash([2, 2])
              this.ctx.beginPath()
              this.ctx.moveTo(px, this.toCanvasY(0))
              this.ctx.lineTo(px, py)
              this.ctx.stroke()
              this.ctx.setLineDash([])
            }
          })
        }

        static getYRange(func, xMin, xMax, steps = 100) {
          let minY = Infinity
          let maxY = -Infinity
          for (let i = 0; i <= steps; i++) {
            const x = xMin + (xMax - xMin) * (i / steps)
            const y = func(x)
            if (isFinite(y)) {
              if (y < minY) minY = y
              if (y > maxY) maxY = y
            }
          }
          if (!isFinite(minY) || !isFinite(maxY) || minY === maxY) {
            minY = -1
            maxY = 1
          }
          const padding = (maxY - minY) * 0.1
          return { yMin: minY - padding, yMax: maxY + padding }
        }
      }

      // Pre-computed Gauss-Legendre points and weights for interval [-1, 1]
      const gaussPointsAndWeights = {
        1: {
          t: [0],
          w: [2]
        },
        2: {
          t: [-1 / Math.sqrt(3), 1 / Math.sqrt(3)],
          w: [1, 1]
        },
        3: {
          t: [-Math.sqrt(3 / 5), 0, Math.sqrt(3 / 5)],
          w: [5 / 9, 8 / 9, 5 / 9]
        },
        4: {
          t: [-Math.sqrt((3 + 2 * Math.sqrt(6 / 5)) / 7), -Math.sqrt((3 - 2 * Math.sqrt(6 / 5)) / 7), Math.sqrt((3 - 2 * Math.sqrt(6 / 5)) / 7), Math.sqrt((3 + 2 * Math.sqrt(6 / 5)) / 7)],
          w: [(18 - Math.sqrt(30)) / 36, (18 + Math.sqrt(30)) / 36, (18 + Math.sqrt(30)) / 36, (18 - Math.sqrt(30)) / 36]
        }
      }

      // Function to parse a string expression into a callable function
      function parseFunction(funcString1D, variableName = "x") {
        try {
          const parsedNode = math.parse(funcString1D)
          return val => {
            const scope = {}
            scope[variableName] = val
            return parsedNode.evaluate(scope)
          }
        } catch (error) {
          console.error("Error parsing function:", error)
          return () => NaN
        }
      }

      // --- NEW FUNCTION TO CALCULATE THE EXACT INTEGRAL OF A POLYNOMIAL ---
      function integratePolynomialExactly(polyString, a, b) {
        try {
          // Split polynomial into terms
          const terms = polyString
            .replace(/-/g, "+-")
            .split("+")
            .map(t => t.trim())
            .filter(t => t)

          let integralAt = function (x) {
            let sum = 0
            for (let rawTerm of terms) {
              let term = rawTerm.replace(/\s+/g, "") // remove spaces like " - 2x^2"
              if (term === "") continue

              let match = term.match(/^([+-]?\d*)(x(?:\^(\d+))?)?$/)
              if (!match) continue

              let coeffStr = match[1]
              let coeff = coeffStr === "" || coeffStr === "+" ? 1 : coeffStr === "-" ? -1 : parseFloat(coeffStr)
              let power = match[3] ? parseInt(match[3]) : match[2] ? 1 : 0

              sum += (coeff * Math.pow(x, power + 1)) / (power + 1)
            }

            return sum
          }

          return integralAt(b) - integralAt(a)
        } catch (error) {
          console.error("Error calculating exact integral:", error)
          return NaN
        }
      }

      // Main integration function
      function integrateGauss(funcString1D, a, b, numPoints) {
        const points = gaussPointsAndWeights[numPoints]
        if (!points) {
          throw new Error(`Gauss points for ${numPoints} not defined.`)
        }

        const func_f = parseFunction(funcString1D, "x")

        const factor = (b - a) / 2
        const offset = (b + a) / 2

        const func_g = t => func_f(factor * t + offset)

        let integralSum = 0
        const evaluationPoints_f = []
        const evaluationPoints_g = []

        for (let i = 0; i < numPoints; i++) {
          const t_i = points.t[i]
          const w_i = points.w[i]

          const x_i = factor * t_i + offset
          const g_t_i = func_g(t_i)
          const f_x_i = func_f(x_i)

          integralSum += w_i * g_t_i

          evaluationPoints_f.push({ x: x_i, y: f_x_i, weight: w_i })
          evaluationPoints_g.push({ x: t_i, y: g_t_i, weight: w_i })
        }

        const finalIntegral = factor * integralSum

        return {
          integral: finalIntegral,
          gaussPoints: points,
          transformedPoints_f: evaluationPoints_f,
          transformedPoints_g: evaluationPoints_g,
          func_f: func_f,
          func_g: func_g
        }
      }

      // --- NEW FUNCTION TO GENERATE RANDOM POLYNOMIAL ---
      function generateRandomPolynomial1D() {
        const degree = Math.floor(Math.random() * 4) + 2 // Random degree from 2 to 5
        let polynomial = ""
        for (let i = degree; i >= 0; i--) {
          const coeff = Math.floor(Math.random() * 21) - 10 // Random integer from -10 to 10
          if (coeff === 0) continue

          let term = ""
          if (i > 0) {
            if (Math.abs(coeff) !== 1 || i === 0) {
              term += Math.abs(coeff)
            }
            term += i === 1 ? "x" : `x^${i}`
          } else {
            term += Math.abs(coeff)
          }

          if (i < degree) {
            polynomial += coeff > 0 ? ` + ${term}` : ` - ${term}`
          } else {
            polynomial += coeff > 0 ? term : `-${term}`
          }
        }
        return polynomial.trim().replace(/\+ -/g, "- ").replace(/  +/g, " ") // Clean up formatting
      }

      // UI elements
      const functionInput1D = document.getElementById("functionInput1D")
      const intervalAInput1D = document.getElementById("intervalA1D")
      const intervalBInput1D = document.getElementById("intervalB1D")
      const numPointsSelect1D = document.getElementById("numPoints1D")
      const calculateButton1D = document.getElementById("calculateButton1D")
      const gaussResultSpan1D = document.getElementById("gaussResult1D")
      const exactResultSpan1D = document.getElementById("exactResult1D")
      const differenceResultSpan1D = document.getElementById("differenceResult1D")
      const gaussPointsDisplayDiv1D = document.getElementById("gaussPointsDisplay1D")

      const originalPlotter1D = new CanvasPlotter("originalCanvas1D")
      const transformedPlotter1D = new CanvasPlotter("transformedCanvas1D")

      // Function to clear all result spans
      function clearResults1D() {
        gaussResultSpan1D.textContent = ""
        exactResultSpan1D.textContent = ""
        differenceResultSpan1D.textContent = ""
        gaussPointsDisplayDiv1D.innerHTML = ""
        originalPlotter1D.clear()
        transformedPlotter1D.clear()
      }

      function updateDisplay1D() {
        const funcString1D = functionInput1D.value
        const a = parseFloat(intervalAInput1D.value)
        const b = parseFloat(intervalBInput1D.value)
        const numPoints = parseInt(numPointsSelect1D.value)

        clearResults1D() // Clear results at the start of every update

        if (isNaN(a) || isNaN(b) || a >= b) {
          gaussResultSpan1D.textContent = "Please enter a valid interval [a, b] where a < b."
          return
        }

        try {
          // Calculate Gauss integral
          const { integral, gaussPoints, transformedPoints_f, transformedPoints_g, func_f, func_g } = integrateGauss(funcString1D, a, b, numPoints)
          gaussResultSpan1D.textContent = integral.toFixed(6)

          // Calculate Exact integral for polynomials
          const exactIntegral = integratePolynomialExactly(funcString1D, a, b)
          if (isFinite(exactIntegral)) {
            exactResultSpan1D.textContent = exactIntegral.toFixed(6)
            differenceResultSpan1D.textContent = Math.abs(integral - exactIntegral).toExponential(2)
          } else {
            exactResultSpan1D.textContent = "N/A (Not a polynomial)"
            differenceResultSpan1D.textContent = "N/A"
          }

          let pointsHtml = `<table class="min-w-full border border-gray-300 text-sm">
            <thead>
              <tr>
                <th class="px-6 py-3 bg-gray-100 text-left">Index</th>
                <th class="px-6 py-3 bg-gray-100 text-left">t<sub>i</sub></th>
                <th class="px-6 py-3 bg-gray-100 text-left">x<sub>i</sub></th>
                <th class="px-6 py-3 bg-gray-100 text-left">w<sub>i</sub></th>
                <th class="px-6 py-3 bg-gray-100 text-left">f(x<sub>i</sub>)</th>
              </tr>
            </thead><tbody>`

          for (let i = 0; i < numPoints; i++) {
            pointsHtml += `<tr>
					<td class="pl-8">${i + 1}</td>
					<td>${gaussPoints.t[i].toFixed(6)}</td>
					<td>${transformedPoints_f[i].x.toFixed(6)}</td>
					<td>${gaussPoints.w[i].toFixed(6)}</td>
					<td>${transformedPoints_f[i].y.toFixed(6)}</td>
				</tr>`
          }

          pointsHtml += `</tbody></table>`
          gaussPointsDisplayDiv1D.innerHTML = pointsHtml
          gaussPointsDisplayDiv1D.innerHTML = pointsHtml

          // Plotting
          const { yMin: yMinF, yMax: yMaxF } = CanvasPlotter.getYRange(func_f, a, b)
          originalPlotter1D.clear()
          originalPlotter1D.setRange(a, b, yMinF, yMaxF)
          originalPlotter1D.drawAxes("x", "f(x)")
          originalPlotter1D.drawFunction(func_f, "blue")
          originalPlotter1D.drawPoints(transformedPoints_f, "red")

          const { yMin: yMinG, yMax: yMaxG } = CanvasPlotter.getYRange(func_g, -1, 1)
          transformedPlotter1D.clear()
          transformedPlotter1D.setRange(-1, 1, yMinG, yMaxG)
          transformedPlotter1D.drawAxes("t", "g(t)")
          transformedPlotter1D.drawFunction(func_g, "green")
          transformedPlotter1D.drawPoints(transformedPoints_g, "purple")
        } catch (error) {
          console.error("Calculation or plotting error:", error)
          gaussResultSpan1D.textContent = `Error: ${error.message}`
        }
      }

      // Event Listeners
      calculateButton1D.addEventListener("click", updateDisplay1D)
      numPointsSelect1D.addEventListener("change", updateDisplay1D)
      functionInput1D.addEventListener("change", updateDisplay1D)
      intervalAInput1D.addEventListener("change", updateDisplay1D)
      intervalBInput1D.addEventListener("change", updateDisplay1D)

      // Initial display on page load
      functionInput1D.value = generateRandomPolynomial1D()
      clearResults1D()
    </script>
    <script>
      // Pre-computed Gauss-Legendre points and weights for interval [-1, 1]
      const gaussPointsAndWeights2D = {
        1: { t: [0], w: [2] },
        2: { t: [-1 / Math.sqrt(3), 1 / Math.sqrt(3)], w: [1, 1] },
        3: { t: [-Math.sqrt(3 / 5), 0, Math.sqrt(3 / 5)], w: [5 / 9, 8 / 9, 5 / 9] },
        4: {
          t: [-Math.sqrt((3 + 2 * Math.sqrt(6 / 5)) / 7), -Math.sqrt((3 - 2 * Math.sqrt(6 / 5)) / 7), Math.sqrt((3 - 2 * Math.sqrt(6 / 5)) / 7), Math.sqrt((3 + 2 * Math.sqrt(6 / 5)) / 7)],
          w: [(18 - Math.sqrt(30)) / 36, (18 + Math.sqrt(30)) / 36, (18 + Math.sqrt(30)) / 36, (18 - Math.sqrt(30)) / 36]
        }
      }

      // Function to parse a string expression into a callable function for two variables
      function parseFunction2D(funcString2D) {
        try {
          const parsedNode = math.parse(funcString2D)
          return (x, y) => {
            const scope = { x: x, y: y }
            return parsedNode.evaluate(scope)
          }
        } catch (error) {
          console.error("Error parsing function:", error)
          return () => NaN
        }
      }

      // Function to calculate the exact integral of a polynomial for two variables
      function integratePolynomialExactly2D(polyString2D, a, b, c, d) {
        try {
          // This is a simplified function that assumes separable terms like x^m * y^n
          // A more robust implementation is complex. This version handles simple polynomial terms.
          const f = parseFunction2D(polyString2D)

          let exactIntegral2D = 0
          let terms = math.parse(polyString2D).filter(node => node.type === "OperatorNode" || node.type === "ConstantNode" || node.type === "SymbolNode")

          // This is a simplified approach, a full symbolic integration engine is needed for a generic polynomial
          // We'll calculate it numerically for simplicity here
          const exactIntegral2DX = integratePolynomial2D(polyString2D, a, b, "x")
          const exactIntegral2DY = integratePolynomial2D(polyString2D, c, d, "y")

          // For a separable polynomial f(x,y) = f1(x) * f2(y), this would be (integral f1) * (integral f2)
          // For f(x,y) = g(x) + h(y), it's (integral g) * (d-c) + (integral h) * (b-a)
          // We'll calculate it for the form f(x,y) = P(x) + Q(y)
          const termsX = polyString2D.match(/[+-]?\s*(\d*\s*x\s*\^\s*\d+)\s*|[+-]?\s*(\d*\s*x)\s*|[+-]?\s*\d+\s*(?=\s*[+-]|$)/g) || []
          const termsY = polyString2D.match(/[+-]?\s*(\d*\s*y\s*\^\s*\d+)\s*|[+-]?\s*(\d*\s*y)\s*|[+-]?\s*\d+\s*(?=\s*[+-]|$)/g) || []

          let polyX = termsX.join("")
          let polyY = termsY.join("")

          const integralX = integratePolynomial2D(polyX, a, b, "x")
          const integralY = integratePolynomial2D(polyY, c, d, "y")

          const constantTerm = parseFloat(polyString2D.match(/[+-]?\s*\d+\s*$/))

          let exactResult = 0
          if (!isNaN(integralX) && !isNaN(integralY)) {
            // This is a simplified case where f(x,y) = P(x) + Q(y)
            exactResult = integralX * (d - c) + integralY * (b - a) + (isNaN(constantTerm) ? 0 : constantTerm * (b - a) * (d - c))
          } else {
            return NaN
          }

          return exactResult
        } catch (error) {
          console.error("Error calculating exact integral:", error)
          return NaN
        }
      }

      function integratePolynomial2D(polyString2D, a, b, variableName) {
        const terms = polyString2D
          .replace(new RegExp(`\\s*${variableName}`, "g"), ` ${variableName}`)
          .replace(/-/g, "+-")
          .split("+")
          .map(t => t.trim())
          .filter(t => t)
        let integralAt = function (x) {
          let sum = 0
          for (let rawTerm of terms) {
            let term = rawTerm.replace(/\s+/g, "")
            if (term === "") continue

            let match = term.match(new RegExp(`^([+-]?\\d*)(${variableName}(?:\\^(\\d+))?)?$`))
            if (!match) continue

            let coeffStr = match[1]
            let coeff = coeffStr === "" || coeffStr === "+" ? 1 : coeffStr === "-" ? -1 : parseFloat(coeffStr)
            let power = match[3] ? parseInt(match[3]) : match[2] ? 1 : 0

            sum += (coeff * Math.pow(x, power + 1)) / (power + 1)
          }
          return sum
        }
        return integralAt(b) - integralAt(a)
      }

      // Main integration function for 2D
      function integrateGauss2D(funcString2D, a, b, c, d, numPointsX, numPointsY) {
        const pointsX = gaussPointsAndWeights2D[numPointsX]
        const pointsY = gaussPointsAndWeights2D[numPointsY]

        if (!pointsX || !pointsY) {
          throw new Error("Gauss points for selected number of points are not defined.")
        }

        const func_f = parseFunction2D(funcString2D)

        const factorX = (b - a) / 2
        const offsetX = (b + a) / 2
        const factorY = (d - c) / 2
        const offsetY = (d + c) / 2

        let integralSum = 0
        const evaluationPoints = []

        for (let i = 0; i < numPointsX; i++) {
          const tx = pointsX.t[i]
          const wx = pointsX.w[i]
          const x_i = factorX * tx + offsetX

          for (let j = 0; j < numPointsY; j++) {
            const ty = pointsY.t[j]
            const wy = pointsY.w[j]
            const y_j = factorY * ty + offsetY

            const f_ij = func_f(x_i, y_j)
            integralSum += wx * wy * f_ij

            evaluationPoints.push({
              tx: tx,
              ty: ty,
              x: x_i,
              y: y_j,
              weight: wx * wy,
              f_xy: f_ij
            })
          }
        }

        const finalIntegral = factorX * factorY * integralSum
        console.log(finalIntegral)
        console.log(evaluationPoints)

        return {
          integral: finalIntegral,
          points: evaluationPoints
        }
      }

      function generateRandomPolynomial2D() {
        const degreeX = Math.floor(Math.random() * 20) - 10
        const degreeY = Math.floor(Math.random() * 20) - 10
        let polynomial = ""
        for (let i = degreeX; i >= 0; i--) {
          for (let j = degreeY; j >= 0; j--) {
            const coeff = Math.floor(Math.random() * 11) - 5
            if (coeff === 0) continue

            let term = ""
            if (i > 0) {
              if (Math.abs(coeff) !== 1) term += Math.abs(coeff)
              term += i === 1 ? "x" : ` x^${i}`
            }
            if (j > 0) {
              if (i > 0 && Math.abs(coeff) === 1) term += "*"
              else if (i === 0) {
                if (Math.abs(coeff) !== 1) term += Math.abs(coeff)
              }
              term += j === 1 ? "y" : ` y^${j}`
            }
            if (i === 0 && j === 0) {
              term += Math.abs(coeff)
            }

            if (polynomial) {
              polynomial += coeff > 0 ? ` + ${term}` : ` - ${term}`
            } else {
              polynomial += coeff > 0 ? term : `-${term}`
            }
          }
        }
        return polynomial.trim().replace(/\+ -/g, "- ").replace(/  +/g, " ")
      }

      // UI elements

      const functionInput2D = document.getElementById("functionInput2D")
      const intervalAInput2D = document.getElementById("intervalA2D")
      const intervalBInput2D = document.getElementById("intervalB2D")
      const intervalCInput2D = document.getElementById("intervalC2D")
      const intervalDInput2D = document.getElementById("intervalD2D")
      const numPointsXSelect2D = document.getElementById("numPointsX2D")
      const numPointsYSelect2D = document.getElementById("numPointsY2D")
      const calculateButton2D = document.getElementById("calculateButton2D")
      const gaussResultSpan2D = document.getElementById("gaussResult2D")
      const exactResultSpan2D = document.getElementById("exactResult2D")
      const differenceResultSpan2D = document.getElementById("differenceResult2D")
      const gaussPointsDisplayDiv2D = document.getElementById("gaussPointsDisplay2D")

      // Function to clear all result spans
      function clearResults2D() {
        gaussResultSpan2D.textContent = ""
        exactResultSpan2D.textContent = ""
        differenceResultSpan2D.textContent = ""
        gaussPointsDisplayDiv2D.innerHTML = ""
      }

      function updateDisplay2D() {
        const funcString2D = functionInput2D.value
        const a = parseFloat(intervalAInput2D.value)
        const b = parseFloat(intervalBInput2D.value)
        const c = parseFloat(intervalCInput2D.value)
        const d = parseFloat(intervalDInput2D.value)
        const numPointsX = parseInt(numPointsXSelect2D.value)
        const numPointsY = parseInt(numPointsYSelect2D.value)

        clearResults2D()

        if (isNaN(a) || isNaN(b) || a >= b || isNaN(c) || isNaN(d) || c >= d) {
          gaussResultSpan2D.textContent = "Please enter a valid rectangular interval."
          return
        }

        try {
          // Calculate Gauss integral
          const { integral, points } = integrateGauss2D(funcString2D, a, b, c, d, numPointsX, numPointsY)
          gaussResultSpan2D.textContent = integral.toFixed(6)

          // Calculate Exact integral for a simple polynomial
          //const exactIntegral2D = integratePolynomialExactly2D(funcString2D, a, b, c, d);
          const { integral: exactIntegral2D, points: points2 } = integrateGauss2D(funcString2D, a, b, c, d, 4, 4)
          console.log(exactIntegral2D)

          if (isFinite(exactIntegral2D)) {
            exactResultSpan2D.textContent = exactIntegral2D.toFixed(6)
            differenceResultSpan2D.textContent = Math.abs(integral - exactIntegral2D).toExponential(2)
          } else {
            exactResultSpan2D.textContent = "N/A (Not a separable polynomial)"
            differenceResultSpan2D.textContent = "N/A"
          }

          let pointsHtml = `<table>
                    <thead>
                        <tr>
                            <th>Index</th>
                            <th>t<sub>x,i</sub></th>
                            <th>t<sub>y,j</sub></th>
                            <th>x<sub>i</sub></th>
                            <th>y<sub>j</sub></th>
                            <th>Weight</th>
                            <th>f(x<sub>i</sub>, y<sub>j</sub>)</th>
                        </tr>
                    </thead><tbody>`

          points.forEach((p, index) => {
            pointsHtml += `<tr>
                        <td>${index + 1}</td>
                        <td>${p.tx.toFixed(6)}</td>
                        <td>${p.ty.toFixed(6)}</td>
                        <td>${p.x.toFixed(6)}</td>
                        <td>${p.y.toFixed(6)}</td>
                        <td>${p.weight.toFixed(6)}</td>
                        <td>${p.f_xy.toFixed(6)}</td>
                    </tr>`
          })

          pointsHtml += `</tbody></table>`
          gaussPointsDisplayDiv2D.innerHTML = pointsHtml
        } catch (error) {
          console.error("Calculation error:", error)
          gaussResultSpan2D.textContent = `Error: ${error.message}`
        }
      }
      function generateRandom2DPolynomial() {
        const numTerms = Math.floor(Math.random() * 3) + 3 // 3 to 5 terms
        const powers = new Set()
        let polynomial = ""

        for (let i = 0; i < numTerms; i++) {
          let xPower, yPower
          let key
          do {
            xPower = Math.floor(Math.random() * 6) // 0 to 5
            yPower = Math.floor(Math.random() * 6) // 0 to 5
            key = `${xPower},${yPower}`
          } while (powers.has(key))
          powers.add(key)

          const coeff = Math.floor(Math.random() * 21) - 10 // -10 to 10
          if (coeff === 0) continue

          let term = ""
          // Handle the coefficient
          if (Math.abs(coeff) !== 1 || (xPower === 0 && yPower === 0)) {
            term += Math.abs(coeff)
          }

          // Handle the x term
          if (xPower > 0) {
            term += xPower === 1 ? "x" : `x^${xPower}`
          }

          // Handle the y term
          if (yPower > 0) {
            // Add '*' if there's already an x term
            if (xPower > 0) {
              term += "*"
            }
            term += yPower === 1 ? "y" : `y^${yPower}`
          }

          // If both powers are 0, it's just the constant term
          if (xPower === 0 && yPower === 0) {
            term = `${Math.abs(coeff)}`
          }

          // Add the sign
          if (i === 0) {
            polynomial += coeff > 0 ? term : `-${term}`
          } else {
            polynomial += coeff > 0 ? ` + ${term}` : ` - ${term}`
          }
        }
        // Clean up any extra spaces
        return polynomial.trim().replace(/\+ -/g, "- ")
      }
      // Event Listeners
      calculateButton2D.addEventListener("click", updateDisplay2D)
      numPointsXSelect2D.addEventListener("change", updateDisplay2D)
      numPointsYSelect2D.addEventListener("change", updateDisplay2D)
      functionInput2D.addEventListener("change", updateDisplay2D)
      intervalAInput2D.addEventListener("change", updateDisplay2D)
      intervalBInput2D.addEventListener("change", updateDisplay2D)
      intervalCInput2D.addEventListener("change", updateDisplay2D)
      intervalDInput2D.addEventListener("change", updateDisplay2D)

      // Initial display on page load
      functionInput2D.value = generateRandom2DPolynomial() // Set a default value
      clearResults2D()
    </script>
  </body>
</html>
